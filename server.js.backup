const express = require("express");
const mongoose = require("mongoose");
const cors = require("cors");
const bodyParser = require("body-parser");
const bcrypt = require("bcrypt");
const jwt = require("jsonwebtoken");
require("dotenv").config();

const app = express();

// --- Environment Variable Checks (Good Practice) ---
// Remove SendGrid checks
if (!process.env.MONGODB_URI) {
  console.error(
    "ERROR: MONGODB_URI environment variable not set. Cannot connect to database."
  );
  process.exit(1); // Exit if DB connection string is missing
}

// --- CORS Configuration ---
const allowedOrigins = [
  "https://atorixit.com", // Main domain
  "https://www.atorixit.com", // Optional www subdomain
  "https://atorix-testing.vercel.app", // Testing domain
  "http://localhost:3000", // For local development
  "http://localhost:5000", // For local development alternative port
  "http://localhost:5001", // For local development alternative port
];

app.use(
  cors({
    origin: function (origin, callback) {
      if (!origin || allowedOrigins.indexOf(origin) !== -1) {
        callback(null, true);
      } else {
        console.warn(`CORS blocked request from origin: ${origin}`);
        callback(new Error("Not allowed by CORS"));
      }
    },
    methods: ["GET", "POST", "DELETE", "OPTIONS"],
    allowedHeaders: ["Content-Type", "Authorization"],
    credentials: true,
  })
);

// --- Middleware ---
app.use(bodyParser.json());

// --- MongoDB Connection ---
mongoose
  .connect(process.env.MONGODB_URI, {
    useNewUrlParser: true,
    useUnifiedTopology: true,
  })
  .then(() => {
    console.log("Connected to MongoDB");
  })
  .catch((err) => {
    console.error("FATAL: Error connecting to MongoDB:", err);
    process.exit(1);
  });

// --- Mongoose Schema and Model ---

// Blog Admin Schema
const blogAdminSchema = new mongoose.Schema({
  username: {
    type: String,
    required: true,
    unique: true,
    trim: true,
    lowercase: true
  },
  password: {
    type: String,
    required: true
  },
  createdAt: {
    type: Date,
    default: Date.now
  }
});

// Hash password before saving
blogAdminSchema.pre('save', async function(next) {
  if (this.isModified('password')) {
    this.password = await bcrypt.hash(this.password, 10);
  }
  next();
});

// Method to compare password
blogAdminSchema.methods.comparePassword = async function(candidatePassword) {
  return bcrypt.compare(candidatePassword, this.password);
};

// User Schema
const userSchema = new mongoose.Schema({
  // Basic info (required)
  name: { type: String, required: [true, "Name is required"], trim: true },
  email: {
    type: String,
    required: [true, "Email is required"],
    trim: true,
    lowercase: true,
  },
  phone: {
    type: String,
    required: [true, "Phone number is required"],
    trim: true,
  },

  // Company info
  company: { type: String, trim: true },

  // Demo form specific fields
  role: { type: String, trim: true },
  interestedIn: { type: [String], default: [] },

  // Common fields
  message: { type: String, trim: true },
  createdAt: { type: Date, default: Date.now },
});

// Admin schema for storing admin login credentials
const adminSchema = new mongoose.Schema({
  username: {
    type: String,
    required: true,
    unique: true,
    trim: true,
    lowercase: true
  },
  password: {
    type: String,
    required: true
  },
  createdAt: {
    type: Date,
    default: Date.now
  }
});

// Blog Admin Schema
const blogAdminSchema = new mongoose.Schema({
  username: {
    type: String,
    required: true,
    unique: true,
    trim: true,
    lowercase: true
  },
  password: {
    type: String,
    required: true
  },
  createdAt: {
    type: Date,
    default: Date.now
  }
});

// Hash password before saving
blogAdminSchema.pre('save', async function(next) {
  if (this.isModified('password')) {
    this.password = await bcrypt.hash(this.password, 10);
  }
  next();
});

// Method to compare password
blogAdminSchema.methods.comparePassword = async function(candidatePassword) {
  return bcrypt.compare(candidatePassword, this.password);
};

const User = mongoose.model("User", userSchema);
const Admin = mongoose.model("Admin", adminSchema);
const BlogAdmin = mongoose.model('BlogAdmin', blogAdminSchema);

// Initialize admin user if none exists
async function initializeAdmin() {
  try {
    console.log('Checking for existing admin users...');
    const adminCount = await Admin.countDocuments();
    console.log(`Found ${adminCount} admin users`);
    
    if (adminCount === 0) {
      const defaultUsername = 'Noopur';
      const defaultPassword = 'Noopur123';
      console.log('Creating default admin user...');

      // Hash the default password
      const saltRounds = 10;
      const hashedPassword = await bcrypt.hash(defaultPassword, saltRounds);
      console.log('Password hashed successfully');

      // Create new admin
      const newAdmin = new Admin({
        username: defaultUsername.toLowerCase().trim(),
        password: hashedPassword
      });

      await newAdmin.save();
      console.log('Default admin user created successfully with username:', defaultUsername);
    } else {
      console.log('Admin user already exists');
      const existingAdmin = await Admin.findOne({});
      console.log('Existing admin username:', existingAdmin?.username);
    }
  } catch (error) {
    console.error('Error initializing admin user:', error);
  }
}

// Initialize admin users
async function initializeBlogAdmin() {
  try {
    const existingAdmin = await BlogAdmin.findOne({ username: 'riddhi' });
    
    if (!existingAdmin) {
      const admin = new BlogAdmin({
        username: 'riddhi',
        password: 'riddhi@123' // This will be hashed by the pre-save hook
      });
      await admin.save();
      console.log('Blog admin user created');
    } else {
      console.log('Blog admin user already exists');
    }
  } catch (error) {
    console.error('Error initializing blog admin user:', error);
  }
}

// Call the initialization functions
initializeAdmin();
initializeBlogAdmin();

// Middleware to verify JWT token
const authenticateToken = (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];
  
  if (!token) return res.sendStatus(401);

  jwt.verify(token, process.env.JWT_SECRET || 'your_jwt_secret', (err, user) => {
    if (err) return res.sendStatus(403);
    req.user = user;
    next();
  });
};

// Middleware to check if user is admin
const isAdmin = (req, res, next) => {
  if (req.user && req.user.role === 'admin') {
    next();
  } else {
    res.status(403).json({ message: 'Access denied. Admin privileges required.' });
  }
};

// Get all users (Admin only)
app.get('/api/blog/users', authenticateToken, isAdmin, async (req, res) => {
  try {
    const users = await User.find({}, 'name email role createdAt');
    res.json(users);
  } catch (error) {
    console.error('Error fetching users:', error);
    res.status(500).json({ message: 'Error fetching users' });
  }
});

// Get single user by ID (Admin only)
app.get('/api/blog/users/:id', authenticateToken, isAdmin, async (req, res) => {
  try {
    const user = await User.findById(req.params.id, '-password');
    if (!user) return res.status(404).json({ message: 'User not found' });
    res.json(user);
  } catch (error) {
    console.error('Error fetching user:', error);
    res.status(500).json({ message: 'Error fetching user' });
  }
});

// Update user role (Admin only)
app.put('/api/blog/users/:id/role', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { role } = req.body;
    if (!['user', 'admin'].includes(role)) {
      return res.status(400).json({ message: 'Invalid role' });
    }
    
    const user = await User.findByIdAndUpdate(
      req.params.id,
      { role },
      { new: true, select: '-password' }
    );
    
    if (!user) return res.status(404).json({ message: 'User not found' });
    
    res.json(user);
  } catch (error) {
    console.error('Error updating user role:', error);
    res.status(500).json({ message: 'Error updating user role' });
  }
});

// Delete user (Admin only)
app.delete('/api/blog/users/:id', authenticateToken, isAdmin, async (req, res) => {
  try {
    const user = await User.findByIdAndDelete(req.params.id);
    if (!user) return res.status(404).json({ message: 'User not found' });
    
    res.json({ message: 'User deleted successfully' });
  } catch (error) {
    console.error('Error deleting user:', error);
    res.status(500).json({ message: 'Error deleting user' });
  }
});

// Blog Admin Login Route
app.post('/api/blog-auth/login', async (req, res) => {
  try {
    console.log('Blog login request received:', req.body);
    const { username, password } = req.body;
    
    if (!username || !password) {
      console.log('Missing username or password');
      return res.status(400).json({ success: false, message: 'Username and password are required' });
    }

    console.log('Looking for blog admin:', username);
    const admin = await BlogAdmin.findOne({ username: username.toLowerCase() });
    
    if (!admin) {
      console.log('Blog admin not found:', username);
      return res.status(401).json({ success: false, message: 'Invalid credentials' });
    }

    console.log('Blog admin found, comparing password...');
    const isMatch = await admin.comparePassword(password);
    console.log('Password match:', isMatch);
    
    if (!isMatch) {
      return res.status(401).json({ success: false, message: 'Invalid credentials' });
    }

    const token = jwt.sign(
      { id: admin._id, username: admin.username, type: 'blogAdmin' },
      process.env.JWT_SECRET || 'your-secret-key',
      { expiresIn: '1d' }
    );

    console.log('Blog login successful for user:', username);
    res.json({
      success: true,
      token,
      user: {
        id: admin._id,
        username: admin.username
      }
    });
  } catch (error) {
    console.error('Blog login error:', error);
    res.status(500).json({ 
      success: false, 
      message: 'Server error',
      error: error.message 
    });
  }
});

// Blog Admin Check Auth
app.get('/api/blog-auth/check-auth', (req, res) => {
  const token = req.headers.authorization?.split(' ')[1];
  
  if (!token) {
    return res.json({ isAuthenticated: false });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'your-secret-key');
    if (decoded.type === 'blogAdmin') {
      return res.json({ 
        isAuthenticated: true, 
        user: { 
          id: decoded.id,
          username: decoded.username 
        } 
      });
    }
    return res.json({ isAuthenticated: false });
  } catch (error) {
    console.error('Auth check error:', error);
    return res.json({ isAuthenticated: false });
  }
});

// --- API Routes ---

// Check if blog admin is authenticated
app.get('/api/blog-auth/check-auth', (req, res) => {
  const token = req.headers.authorization?.split(' ')[1];
  
  if (!token) {
    return res.status(401).json({ isAuthenticated: false });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'your-secret-key');
    if (decoded.type === 'blogAdmin') {
      return res.json({ isAuthenticated: true, user: { username: decoded.username } });
    }
    return res.status(401).json({ isAuthenticated: false });
  } catch (error) {
    return res.status(401).json({ isAuthenticated: false });
  }
});

// === Simple Ping Endpoint to Wake Up Server ===
app.get("/api/ping", (req, res) => {
  res
    .status(200)
    .json({
      status: "ok",
      message: "Server is awake",
      timestamp: new Date().toISOString(),
    });
});

// === Admin Authentication Route ===
app.post("/api/admin/login", async (req, res) => {
  console.log('\n=== Login Attempt ===');
  console.log('Request body:', JSON.stringify(req.body, null, 2));
  
  try {
    const { username, password } = req.body;

    // Basic validation
    if (!username || !password) {
      console.log('âŒ Missing username or password');
      return res.status(400).json({
        success: false,
        message: "Username and password are required"
      });
    }

    // Debug: List all admin users
    const allAdmins = await Admin.find({});
    console.log('ðŸ” All admin users in DB:', JSON.stringify(allAdmins.map(a => ({
      username: a.username,
      passwordLength: a.password?.length,
      createdAt: a.createdAt
    })), null, 2));

    // Find admin user
    console.log('ðŸ” Looking for admin with username (case sensitive):', `'${username}'`);
    const admin = await Admin.findOne({ username: username.trim() });
    
    if (!admin) {
      console.log('âŒ No admin found with username:', username);
      // Try case-insensitive search to help debug
      const allUsernames = (await Admin.find({})).map(a => a.username);
      console.log('â„¹ï¸  Existing usernames in DB:', allUsernames);
      
      return res.status(401).json({
        success: false,
        message: "Invalid username or password",
        debug: { existingUsernames: allUsernames }
      });
    }
    
    console.log('âœ… Admin found:', {
      id: admin._id,
      username: admin.username,
      createdAt: admin.createdAt,
      passwordStartsWith: admin.password.substring(0, 5) + '...',
      passwordLength: admin.password.length
    });

    // Verify password
    console.log('ðŸ”‘ Verifying password...');
    console.log('ðŸ”‘ Input password length:', password.length);
    console.log('ðŸ”‘ Stored hash length:', admin.password.length);
    
    // Direct password comparison for debugging (remove in production)
    const directCompare = password === 'Noopur123';
    console.log('ðŸ”‘ Direct comparison with Noopur123:', directCompare);
    
    const passwordMatch = await bcrypt.compare(password, admin.password);
    console.log('ðŸ”‘ bcrypt.compare result:', passwordMatch);

    if (!passwordMatch) {
      console.log('âŒ Password does not match');
      console.log('ðŸ”‘ Input password:', `'${password}'`);
      console.log('ðŸ”‘ Expected password: Noopur123');
      return res.status(401).json({
        success: false,
        message: "Invalid username or password",
        debug: {
          usernameMatched: true,
          passwordMatch: false,
          inputLength: password.length,
          storedHashLength: admin.password.length
        }
      });
    }

    // Generate a simple token (in a production app, you would use JWT)
    const token = `atorix_dashboard_${Date.now()}_${Buffer.from(username).toString('base64')}`;

    res.status(200).json({
      success: true,
      token,
      message: "Login successful"
    });
  } catch (error) {
    console.error("Error during admin login:", error);
    res.status(500).json({
      success: false,
      message: "Internal server error"
    });
  }
});

// === Change Admin Password Route ===
app.post("/api/admin/change-password", async (req, res) => {
  try {
    const { username, currentPassword, newPassword } = req.body;

    // Basic validation
    if (!username || !currentPassword || !newPassword) {
      return res.status(400).json({
        success: false,
        message: "Username, current password, and new password are required"
      });
    }

    // Find admin user
    const admin = await Admin.findOne({ username: username.toLowerCase() });

    // Check if admin exists
    if (!admin) {
      return res.status(401).json({
        success: false,
        message: "Invalid username"
      });
    }

    // Verify current password
    const passwordMatch = await bcrypt.compare(currentPassword, admin.password);

    if (!passwordMatch) {
      return res.status(401).json({
        success: false,
        message: "Current password is incorrect"
      });
    }

    // Hash new password
    const saltRounds = 10;
    const hashedPassword = await bcrypt.hash(newPassword, saltRounds);

    // Update password
    admin.password = hashedPassword;
    await admin.save();

    res.status(200).json({
      success: true,
      message: "Password updated successfully"
    });
  } catch (error) {
    console.error("Error during password change:", error);
    res.status(500).json({
      success: false,
      message: "Internal server error"
    });
  }
});

// === Form Submission Route ===
app.post("/api/submit", async (req, res) => {
  // Destructure inputs
  const {
    name: nameInput,
    email: emailInput,
    phone: phoneInput,
    company: companyInput,
    role: roleInput,
    interestedIn: interestedInInput,
    message: messageInput,
  } = req.body;

  // Trim values or use default if null/undefined
  const name = nameInput?.trim();
  const email = emailInput?.trim().toLowerCase();
  const phone = phoneInput?.trim();
  const company = companyInput?.trim() || "";
  const role = roleInput?.trim() || "";
  // interestedIn should be an array of strings; ensure it is
  let interestedIn = [];
  if (Array.isArray(interestedInInput)) {
    interestedIn = interestedInInput
      .map((item) => item.trim())
      .filter((item) => item.length > 0);
  } else if (
    typeof interestedInInput === "string" &&
    interestedInInput.trim().length > 0
  ) {
    // If a single string is sent, convert to array
    interestedIn = [interestedInInput.trim()];
  }
  const message = messageInput?.trim() || "";

  // --- Backend Validation ---
  if (!name || !email || !phone) {
    return res
      .status(400)
      .json({ message: "Please fill in Name, Email, and Phone Number." });
  }

  try {
    // --- Check for existing user by email OR phone number ---
    const existingUser = await User.findOne({
      $or: [{ email: email }, { phone: phone }],
    }).lean();

    if (existingUser) {
      let conflictMessage =
        "This record cannot be added because of a duplicate entry.";
      if (existingUser.email === email) {
        conflictMessage =
          "This email address is already registered. Please use a different email.";
      } else if (existingUser.phone === phone) {
        conflictMessage =
          "This phone number is already registered. Please use a different number.";
      }
      return res.status(400).json({ message: conflictMessage });
    }

    const newUser = new User({
      name,
      email,
      phone,
      company,
      role,
      interestedIn,
      message,
    });

    const savedUser = await newUser.save();

    // --- Success Response to Frontend ---
    return res
      .status(201)
      .json({ message: "Registration successful! We will contact you soon." });
  } catch (dbError) {
    // Catch errors from findOne or save operations
    console.error(
      "!!! Error during database operation in /api/submit:",
      dbError
    );
    // If it's a validation error from Mongoose (e.g., required field missing despite frontend check failing)
    if (dbError.name === "ValidationError") {
      return res.status(400).json({ message: dbError.message });
    }
    // Otherwise, assume internal server error
    return res
      .status(500)
      .json({
        message: "An internal server error occurred. Please try again later.",
        error: dbError.message,
      });
  }
});

// === Fetch Leads Route ===
app.get("/api/leads", async (req, res) => {
  try {
    const users = await User.find().sort({ createdAt: -1 }).lean();
    res.status(200).json(users);
  } catch (error) {
    console.error("Error fetching leads:", error);
    res
      .status(500)
      .json({ message: "Failed to fetch leads.", error: error.message });
  }
});

// === Delete Lead Route ===
app.delete("/api/leads/:id", async (req, res) => {
  try {
    const { id } = req.params;
    if (!mongoose.Types.ObjectId.isValid(id)) {
      return res.status(400).json({ message: "Invalid lead ID format." });
    }
    const deletedUser = await User.findByIdAndDelete(id);
    if (!deletedUser) {
      return res.status(404).json({ message: "Lead not found." });
    }
    res.status(200).json({ message: "Lead deleted successfully." });
  } catch (error) {
    console.error(`Error deleting lead with ID (${req.params.id}):`, error);
    res
      .status(500)
      .json({
        message: "Internal Server Error occurred while deleting.",
        error: error.message,
      });
  }
});

// === Submissions Management Endpoints ===

// Get all form submissions
app.get("/api/submissions", async (req, res) => {
  try {
    // Fetch all submissions from the User collection (same as leads)
    const submissions = await User.find().sort({ createdAt: -1 }).lean();
    res.status(200).json({
      success: true,
      submissions,
    });
  } catch (error) {
    console.error("Error fetching submissions:", error);
    res.status(500).json({
      success: false,
      message: "Failed to fetch submissions",
      error: error.message,
    });
  }
});

// Delete a single submission
app.delete("/api/submissions/:id", async (req, res) => {
  try {
    const { id } = req.params;
    if (!mongoose.Types.ObjectId.isValid(id)) {
      return res.status(400).json({
        success: false,
        message: "Invalid submission ID format",
      });
    }
    const deletedSubmission = await User.findByIdAndDelete(id);
    if (!deletedSubmission) {
      return res.status(404).json({
        success: false,
        message: "Submission not found",
      });
    }
    res.status(200).json({
      success: true,
      message: "Submission deleted successfully",
    });
  } catch (error) {
    console.error("Error deleting submission:", error);
    res.status(500).json({
      success: false,
      message: "Failed to delete submission",
      error: error.message,
    });
  }
});

// Bulk delete submissions
app.post("/api/submissions/bulk-delete", async (req, res) => {
  try {
    const { ids } = req.body;

    if (!ids || !Array.isArray(ids) || ids.length === 0) {
      return res.status(400).json({
        success: false,
        message: "Invalid request: ids array is required",
      });
    }

    // Validate all IDs
    const invalidIds = ids.filter((id) => !mongoose.Types.ObjectId.isValid(id));
    if (invalidIds.length > 0) {
      return res.status(400).json({
        success: false,
        message: `Invalid ObjectId(s): ${invalidIds.join(", ")}`,
      });
    }

    const result = await User.deleteMany({
      _id: { $in: ids },
    });

    res.status(200).json({
      success: true,
      message: `${result.deletedCount} submissions deleted successfully`,
      count: result.deletedCount,
    });
  } catch (error) {
    console.error("Error bulk deleting submissions:", error);
    res.status(500).json({
      success: false,
      message: "Failed to delete submissions",
      error: error.message,
    });
  }
});

// --- Basic Root Route ---
app.get("/", (req, res) => {
  res.status(200).send("Atorix Backend is running.");
});

// --- Global Error Handler ---
app.use((err, req, res, next) => {
  if (err.message === "Not allowed by CORS") {
    console.error(
      `CORS Error caught by global handler: ${err.message} from origin ${req.header("Origin")}`
    );
    return res.status(403).json({ message: "Access denied by CORS policy." });
  }
  console.error(
    "!!! Unhandled Error Caught by Global Handler:",
    err.stack || err
  );
  res
    .status(500)
    .json({ message: "An unexpected internal server error occurred." });
});

// --- Debug Endpoint ---
app.get('/api/admin/debug', async (req, res) => {
  try {
    const admins = await Admin.find({});
    res.json({
      adminCount: admins.length,
      admins: admins.map(a => ({
        username: a.username,
        passwordHash: a.password,
        createdAt: a.createdAt
      }))
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// --- Start Server ---
const PORT = process.env.PORT || 3001;
app.listen(PORT, () => {
  console.log(`Server is running on port ${PORT}`);
  console.log(`API Documentation available at http://localhost:${PORT}/api-docs`);
  console.log(`Test endpoints:`);
  console.log(`- GET  http://localhost:${PORT}/api/ping`);
  console.log(`- POST http://localhost:${PORT}/api/blog-auth/login`);
  console.log(`- GET  http://localhost:${PORT}/api/blog-auth/check-auth`);
  console.log(`Debug endpoint: http://localhost:${PORT}/api/admin/debug`);
});
